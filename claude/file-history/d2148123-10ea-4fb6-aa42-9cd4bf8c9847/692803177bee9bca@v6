#![allow(dead_code)]

struct Solution;

impl Solution {
    pub fn longest_common_prefix(strs: Vec<String>) -> String {
        if strs.is_empty() {
            return String::new();
        }

        let mut result: String = strs[0].clone();

        for s in strs.iter().skip(1) {
            while !s.starts_with(&result) {
                result.pop();
                if result.is_empty() {
                    return String::new();
                }
            }
        }

        result
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;

    #[test]
    fn test_hello() {
        let input: Vec<String> = vec![
            "flower".to_string(),
            "flow".to_string(),
            "flight".to_string(),
        ];
        let expected: String = "fl".to_string();
        let answer: String = Solution::longest_common_prefix(input);
        assert_eq!(expected, answer);
    }

    #[test]
    fn test_non_matching() {
        let input: Vec<String> = vec!["dog".to_string(), "racecar".to_string(), "car".to_string()];
        let expected = "".to_string();
        let answer = Solution::longest_common_prefix(input);
        assert_eq!(expected, answer);
    }
}
