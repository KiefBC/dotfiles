struct Solution;
//IMPORTANT!! Submit Code Region Begin(Do not remove this line)
impl Solution {
    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
        if nums.is_empty() {
            return 0;
        }

        let mut write_pos = 1; // Position to write next unique element

        for read_pos in 1..nums.len() {
            // If current element differs from previous unique element
            if nums[read_pos] != nums[write_pos - 1] {
                nums[write_pos] = nums[read_pos];
                write_pos += 1;
            }
        }

        nums.truncate(write_pos);
        write_pos as i32
    }
}
//IMPORTANT!! Submit Code Region End(Do not remove this line)

#[cfg(test)]
pub mod tests {
    use super::*;
    
    #[test]
    fn test_foo() {
        let mut expected = vec![1, 1, 2];
        let answer = Solution::remove_duplicates(&mut expected);
        assert_eq!(answer, 2);
    }
}