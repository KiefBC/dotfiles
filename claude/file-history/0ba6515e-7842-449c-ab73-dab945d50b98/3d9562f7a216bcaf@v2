#![allow(dead_code)]
struct Solution;

impl Solution {
    pub fn longest_palindrome(s: String) -> String {
        if s.is_empty() {
            return String::new();
        }

        let chars: Vec<char> = s.chars().collect();
        let mut sp: usize = 0;
        let mut ep: usize = 0;

        for i in 0..chars.len() {
            let first: usize = expand(&chars, i, i);
            let second: usize = expand(&chars, i, i + 1);
            let cp: usize = first.max(second);

            if cp > ep {
                ep = cp;
                sp = i - (cp - 1) / 2;
            }
        }

        chars[sp..sp + ep].iter().collect()
    }
}

fn expand(chars: &[char], mut l: usize, mut r: usize) -> usize {
    while r < chars.len() && chars[l] == chars[r] {
        if l == 0 {
            break;
        }

        l -= 1;
        r += 1;
    }

    if l == 0 && r < chars.len() && chars[l] == chars[r] {
        r + 1
    } else {
        r - l - 1
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_three_values() {
        let input: String = "babad".to_string();
        let expected: String = "bab".to_string();
        let answer: String = Solution::longest_palindrome(input);

        assert_eq!(expected, answer);
    }

    #[test]
    fn test_four_values() {
        let input: String = "cbbd".to_string();
        let expected: String = "bb".to_string();
        let answer: String = Solution::longest_palindrome(input);

        assert_eq!(expected, answer);
    }

    #[test]
    fn test_no_values() {
        let input: String = "".to_string();
        let expected: String = "".to_string();
        let answer: String = Solution::longest_palindrome(input);

        assert_eq!(expected, answer);
    }

    #[test]
    fn test_single_character() {
        let input: String = "a".to_string();
        let expected: String = "a".to_string();
        let answer: String = Solution::longest_palindrome(input);

        assert_eq!(expected, answer);
    }

    #[test]
    fn test_two_characters() {
        let input: String = "aa".to_string();
        let expected: String = "aa".to_string();
        let answer: String = Solution::longest_palindrome(input);

        assert_eq!(expected, answer);
    }
}
